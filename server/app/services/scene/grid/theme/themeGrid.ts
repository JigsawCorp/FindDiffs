import { StackEmptyException } from "../../../../../../common/errors/stackEmptyException";
import { ICommon3DPosition } from "../../../../../../common/model/positions";
import { ThemeSurface } from "../../../../../../common/model/scene/objects/thematicObjects/thematicObject";
import { ICommonSceneDimensions } from "../../../../../../common/model/scene/scene";
import { EnumUtils } from "../../../../utils/enumUtils";
import { RandomUtils } from "../../../../utils/randomUtils";
import { Grid } from "../grid";
import { IThemeGridPosition } from "./IThemeGridPosition";
import * as GamePositions from "./positions.json";

export interface IPositionGridTheme extends ICommon3DPosition {
    surface: ThemeSurface;
}

export class ThemeGrid extends Grid {

    /**
     * The position file is generated by the software blender. These are the potential
     * positions where the object can be placed. This gives a better result as we can
     * fine tune the exact position of each objects.
     */

    // tslint:disable-next-line:no-magic-numbers
    public static readonly GENERATION_FACTOR: number[] = [30, 40, 30];
    private static readonly SUM_GEN_FACTOR: number = 100;
    private static readonly NUMBER_POSITION: number = 250;

    private availablePositions: IThemeGridPosition;

    public constructor(dimensions: ICommonSceneDimensions, minDistancePos: number) {
        super(dimensions, minDistancePos);
        this.availablePositions = JSON.parse(JSON.stringify(GamePositions));
    }

    protected generateGrid(): void {
        this.availablePositions = JSON.parse(JSON.stringify(GamePositions));

        for (let i: number = 0; i < ThemeGrid.NUMBER_POSITION; i++) {
            this.positions.push(this.choosePosition());
        }
    }

    private choosePosition(): IPositionGridTheme {
        const surfaceChoice: ThemeSurface = this.chooseSurfaceType();
        const surfaceName: string = ThemeSurface[surfaceChoice].toLowerCase();

        const surfacePositions: ICommon3DPosition[] = this.availablePositions[surfaceName];
        if (surfacePositions.length < 1) {

            return this.findRemainingPositions();
        }
        const choice: number = RandomUtils.inRangeInt(0, surfacePositions.length - 1);
        const position: IPositionGridTheme = this.positionToThemePosition(surfacePositions[choice], surfaceChoice);
        position.surface = surfaceChoice;

        this.availablePositions[surfaceName].splice(choice, 1);

        return position;
    }

    private findRemainingPositions(): IPositionGridTheme {
        for (let i: number = 0; i < EnumUtils.enumLength(ThemeSurface); i++) {
            const surfaceName: string = ThemeSurface[i].toLowerCase();
            if (this.availablePositions[surfaceName].length > 0) {
                const choice: number = RandomUtils.inRangeInt(0, this.availablePositions[surfaceName].length - 1);

                return this.positionToThemePosition(
                    this.availablePositions[surfaceName].splice(choice, 1)[0],
                    i as ThemeSurface,
                );
            }
        }
        throw new StackEmptyException();
    }

    private chooseSurfaceType(): ThemeSurface {
        const choice: number = RandomUtils.random(ThemeGrid.SUM_GEN_FACTOR);
        let factorSum: number = 0;

        let lastIndex: number = ThemeGrid.GENERATION_FACTOR.length - 1;
        for (let i: number = 0; i < ThemeGrid.GENERATION_FACTOR.length; i++) {
            factorSum += ThemeGrid.GENERATION_FACTOR[i];
            if (choice < factorSum) {
                lastIndex = i;
                break;
            }
        }

        return lastIndex as ThemeSurface;
    }

    private positionToThemePosition(position: ICommon3DPosition, surface: ThemeSurface): IPositionGridTheme {
        return {
            surface: surface,
            x: position.x,
            y: position.y,
            z: position.z,
        };
    }
}
